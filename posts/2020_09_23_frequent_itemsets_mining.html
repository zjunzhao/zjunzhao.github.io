<!DOCTYPE html>

<html>

<head>
	<meta charset='UTF-8'>
	<link rel='stylesheet' type='text/css' href='../css/post_style.css'>
	<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {inlineMath: [ ['$','$'], ["\\(","\\)"] ],
				  displayMath: [ ['$$','$$'], ["\\[","\\]"] ]}});
	</script>
	<script type="text/javascript" async 
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
	<title>frequent itemsets mining</title>
</head>

<body>
	<div class='navbar'>
		<ul>
			<li><a href='../index.html'>主页</a></li>
			<li></li>
		</ul>
	</div>
	<div class='post_title'>
		<b><span style='font-size:30px'>频繁项集挖掘（Frequent Itemsets Mining）</span></b>
	</div>
	<div class='post_content'>
		<p>一家超市的决策者，经常需要考虑如下两个问题。第一个问题是，如何摆放商品，或者说，该将哪些商品摆放在一起。直观上想，如果决策者能看到过去一段时间超市的营业数据，并且营业数据反映用户经常同时购买某些商品，比如经常同时购买牛奶和面包，那么决策者就应该将牛奶和面包放在一起，这样能帮助同时购买牛奶和面包的用户节省一些找商品的时间，他们的购买体验会更好。第二个问题是，假如某个商品降价了，那么其它商品的价格怎么调整，能让超市的收入更高。仍然以牛奶和面包为例，假设降价的商品是牛奶，直观上想，这时候给面包涨价应该是一个比较合适的决策。这是因为买了牛奶的用户一般也会买面包，当用户在超市里买了牛奶后，为了方便，也会在同一家超市买面包，因此将面包涨价就能增长超市的收入。</p>
		<p>在上面的例子里，我们可以看到，在超市的经营决策中，从营业数据中发现“哪些商品更可能同时被用户购买”和“用户购买了某些商品，就很可能会购买另一些商品”这类的规律是一件很有用的事情。在数据挖掘（Data Mining）领域中，频繁项集挖掘（Frequent Itemsets Mining）就是研究如何从数据中发现这类规律的一个课题，下面我将介绍这个课题最基本的定义和算法。</p>
		</br>
		<p><b>频繁项集（Frequent Itemset）和关联规则（Association Rule）</b></p>
		<p>首先我们需要先定义这个课题所考虑的数据类型。频繁模式挖掘这个课题一般假设我们有 $n$ 个项（Item，也可以翻译为商品）和 $m$ 个篮子（basket），每个篮子里有若干个项。这 $m$ 个篮子组成的数据就称为满足购物篮模型（the Market-Basket Model）要求的数据。下面总结一下购物篮模型的定义。</p>
		<p>定义（购物篮模型）：设集合 $I$ 为全体项组成的集合（项的全集），$B_1,B_2,...,B_m$ 是 $I$ 的子集，那么称数据 $D=\{B_1,B_2,...,B_m\}$ 是满足购物篮模型要求的数据，并将 $B_i$ 称为第 $i$ 个篮子。</p>
		<p>为了能准确描述“哪些商品更可能同时被用户购买”这个事情，我们需要定义项集（Itemset）和频繁项集（Frequent Itemset）这两个概念。我们将项的集合称为项集，换句话说，项的全集的任一个子集，都是一个项集。对于包含 $k$ 个项的项集，我们称其为 $k$-项集。一个项集 $S$ 在数据中出现的次数（包含 $S$ 的篮子的数目）称为这个项集的支持数（support），简记为 $supp(S)$。直观上想，频繁项集就是出现得比较频繁的项集，也就是支持数较大的项集。为了精确描述“频繁”这个事情，我们需要预先给定一个支持数阈值（Support Threshold），并称支持数不少于这个支持数阈值的项集为频繁项集。同样，包含 $k$ 个项的频繁项集称为频繁 $k$-项集。下面总结一下频繁项集的定义。</p>
		<p>定义（频繁项集）：设支持数阈值为 $s$，称项集 $S$ 为频繁项集，若 $supp(S)\ge s$。</p>
		<p>上面我们已经成功抽象出用于描述“哪些商品更可能同时被用户购买”的精确概念，接下来需要抽象出能够描述“用户购买了某些商品，就很可能会购买另一些商品”的精确概念。考虑两个不交的项集 $S_1$ 和 $S_2$，我们希望知道假如一个用户购买了 $S_1$ 中的全部商品后，会有多大可能购买 $S_2$。这个可能性用概率来描述就是
		$$P\{用户购买了 S_2 中的商品|用户购买了 S_1 中的商品\}=\frac{P\{用户购买了 S_1\cup S_2 中的商品\}}{P\{用户购买了 S_1 中的商品\}}$$
		为了方便，将这个公式简记为
		$$P(S_2|S_1)=\frac{P(S_1\cup S_2)}{P(S_1)}$$
		由于我们手上有用户的数据，因此可以用频率值估计这个概率值，就有
		$$\hat{P}(S_2|S_1)=\frac{\hat{P}(S_1\cup S_2)}{\hat{P}(S_1)}=\frac{\frac{supp(S_1\cup S_2)}{m}}{\frac{supp(S_1)}{m}}=\frac{supp(S_1\cup S_2)}{supp(S_1)}$$
		我们称形如“用户购买了 $S_1$ 中的全部商品，就会购买 $S_2$ 中的全部商品”这样的规则为关联规则（Association Rule），记为 $S_1\to S_2$，并称 $\hat{P}(S_2|S_1)$ 为这个关联规则的置信度（Confidence），记为 $conf(S_1\to S_2)$。下面总结一下关联规则和关联规则的置信度的定义。
		</p>
		<p>定义（关联规则）：设 $S_1$ 和 $S_2$ 是不交的项集，称“用户购买了 $S_1$ 中的全部商品，就会购买 $S_2$ 中的全部商品”为一条关联规则，记为 $S_1\to S_2$。</p>
		<p>定义（关联规则的置信度）：称关联规则 $S_1\to S_2$ 的置信度为 $conf(S_1\to S_2)=\frac{supp(S_1\cup S_2)}{supp(S_1)}$。</p>
		<p>直观上想，置信度越大的关联规则，应该是越有用的关联规则，但事实并不是这样。假设来超市购物的所有用户都买了矿泉水这个商品，那么对任意一个商品，比如铅笔，会有
		$$conf(\{铅笔\}\to\{矿泉水\})=\frac{supp(\{铅笔，矿泉水\})}{supp(\{铅笔\})}=1$$
		这条关联规则的置信度很大，但并不能反映任何因果关系，因为这时候从概率的角度来看（假设样本空间是数据），铅笔和矿泉水的购买是两个独立的事件，也就是
		$$P(\{矿泉水\}|\{铅笔\})=P(\{矿泉水\})$$
		由此可见，对于关联规则 $S_1\to S_2$，当 $\frac{\hat{P}(S_2|S_1)}{\hat{P}(S_1)}=1$ 时，这条关联规则就基本没什么用处了。因此我们将 $\frac{\hat{P}(S_2|S_1)}{\hat{P}(S_1)}$ 称为关联规则 $S_1\to S_2$ 的提升度（Lift），作为关联规则的有效性的一个评价指标。下面总结一下关联规则的提升度的定义。</p>
		<p>定义（关联规则的提升度）：称关联规则 $S_1\to S_2$ 的提升度为
		$$lift(S_1\to S_2)=\frac{\hat{P}(S_2|S_1)}{\hat{P}(S_1)}=\frac{m\cdot supp(S_1\cup S_2)}{supp(S_1)supp(S_2)}$$</p>
		<p>由提升度的定义可见，当一条关联规则的提升度较大时（远大于 $1$），就说明相比于不完全购买 $S_1$ 中的商品的用户，完全购买 $S_1$ 中的商品的用户更可能完全购买 $S_2$ 中的商品。当一条关联规则的提升度较小时（远小于 $1$），就说明相比于不完全购买 $S_1$ 中的商品的用户，完全购买 $S_1$ 中的商品的用户更不可能完全购买 $S_2$ 中的商品。当一条关联规则的提升度接近 $1$ 时，就说明用户是否完全购买 $S_2$ 中的商品，和用户是否完全购买 $S_1$ 中的商品，没有太大关系。</p>
		<p>我们一般倾向于从数据中挖掘满足 $supp(S_1\cup S_2)$ 和 $conf(S_1\to S_2)$ 都比较大的关联规则（如果 $S_1\cup S_2$ 不是频繁项集，那么这条关联规则可能不会带来太多商业利润），再用提升度等指标筛选出真正有效的关联规则。而关联规则的挖掘，可以归结为频繁项集的挖掘，只要找到所有的频繁项集，那对于任意一个频繁项集 $S$，枚举其子集 $S_1$，令 $S_2=S-S_1$，再验证置信度，就可以得到所有满足要求的关联规则。因此下面主要讨论挖掘频繁项集的算法。</p>
		</br>
		<p><b>Apriori算法及其变种</b></p>
		<p>本节主要叙述挖掘频繁项集的算法。先来复述一下算法需要解决的任务，如下所示。</p>
		<p>任务（频繁项集挖掘）：给定数据，预先定义整数 $k$ 和 $s$，求满足有 $k$ 个商品，并且支持数不少于 $s$ 的全体项集。</p>
		<p>首先，很容易给出一个暴力算法（Brute-Force Algorithm）作为解法，如下所示。</p>
		<p>算法（暴力算法）：
		<ul>
		<li>给 $C_n^k$ 个频繁项集候选各自分配一个计数器。</li>
		<li>遍历数据，对每个篮子，枚举它的全体包含 $k$ 个商品的子集，对这些项集的计数器加 $1$。</li>
		<li>遍历 $C_n^k$ 个频繁项集候选，返回计数器值不小于 $s$ 的项集。</li>
		</ul>
		</p>
		<p>可以看到，这个暴力算法不管是在时间复杂度，还是空间复杂度上，都是很爆炸的。时间复杂度倒是能勉强接受，这是因为实际使用中，篮子的元素数目和 $k$ 的值一般很小，因此对计数器的操作次数也不会特别多。但空间复杂度经常是没法接受的，因为商品数量 $n$ 一般是很大的，即使 $k$ 很小（如 $k=2$），内存的存储空间可能不够维护 $C_n^k$ 个计数器。</p>
		<p>但事实上，并不是所有的 $k$-项集都需要作为频繁 $k$-项集候选，我们可以找到一些简单的规则筛选掉一些不可能是 $k$-频繁项集的 $k$-项集。比如，先预处理得到所有的频繁项（这只需要 $n$ 个计数器，空间复杂度是可以接受的），那么，对于一个 $k$-项集，假如它包含一个非频繁项，那它肯定不可能是频繁 $k$-项集。更一般的，我们有如下命题。</p>
		<p>命题（频繁项集的必要条件）：设 $S_1$，$S_2$ 是两个项集，并且 $S_1\subset S_2$，那么若 $S_2$ 是频繁项集，则 $S_1$ 是频繁项集。</p>
		<p>根据这个命题，我们可以看出，一个项集是频繁项集，当且仅当它的全部项集都是频繁项集。利用这条性质，研究人员提出Apriori算法（Apriori Algorithm），从小到大地来求解频繁项集，在实际使用中大幅度降低了内存消耗，算法步骤如下所示。</p>
		<p>算法（Apriori算法）：
		<ul>
		<li>用暴力算法求解频繁 $1$-项集（即频繁项），并删掉数据中所有的非频繁项（减小了部分篮子的大小）。</li>
		<li>假设已经求解得到全体频繁 $j$-项集，下面求解全体频繁 $j+1$-项集
			<ul>
			<li>对每个频繁 $j$-项集，枚举可以加入的项（这个项满足（1）没在这个 $j$-项集中出现过（2）项的序号比 $j$-项集中的 $j$ 个项都大），得到一个 $j+1$-项集。检查这个 $j+1$-项集的全体 $j$-项集子集是否是频繁 $j$-项集，如果是，那就给它分配一个计数器。</li>
			<li>遍历数据，对每个篮子，枚举它的全体 $j+1$-项集子集，对这些项集，若有计数器，则计数器加 $1$。</li>
			<li>遍历所有有计数器的 $j+1$-项集，计数器值不小于 $s$ 的即为频繁 $j+1$-项集。</li>
			</ul>
		</li>
		</ul>
		</p>
		<p>相比于暴力算法，Apriori算法减少了频繁 $k$-项集候选的数目，节省了内存开销，但可能增加了时间开销（不考虑删除数据中的非频繁项这个操作，Apriori算法需要遍历 $k$ 次数据，而暴力算法只需要遍历 $1$ 次数据。实际应用中 $m$ 一般较大（因此数据只能存储在硬盘中），所以遍历数据的时间开销是最主要的时间开销）。</p>
		<p>事实上，算法的内存消耗还能进一步减小，下面介绍的PCY算法（Algorithm of Park，Chen and Yu）在Apriori算法的基础上，设计规则，进一步筛选掉不合法的频繁 $k$-项集候选。算法如下所示。</p>
		<p>算法（PCY算法）：
		<ul>
		<li>用暴力算法求解频繁 $1$-项集（即频繁项），并删掉数据中所有的非频繁项（减小了部分篮子的大小）。</li>
		<li>假设已经求解得到全体频繁 $j$-项集，下面求解全体频繁 $j+1$-项集
			<ul>
			<li>创建 $u$ 个计数器，定义一个从 $j+1$-项集到计数器编号的哈希函数。</li>
			<li>遍历数据，对每个篮子，枚举它的全体 $j+1$-项集子集，检查每个 $j+1$-项集的全体 $j$-项集子集是否是频繁 $j$-项集，如果是，用哈希函数算出这个 $j+1$-项集对应的计数器编号，将该编号对应的计数器加 $1$。</li>
			<li>对每个频繁 $j$-项集，枚举可以加入的项（这个项满足（1）没在这个 $j$-项集中出现过（2）项的序号比 $j$-项集中的 $j$ 个项都大），得到一个 $j+1$-项集。检查这个 $j+1$-项集的全体 $j$-项集子集是否是频繁 $j$-项集，如果是，用哈希函数算出它对应的计数器编号，检查该编号对应的计数器的值是否不小于 $s$，如果是，那就给它分配一个新计数器。</li>
			<li>遍历数据，对每个篮子，枚举它的全体 $j+1$-项集子集，对这些项集，若有计数器，则计数器加 $1$。</li>
			<li>遍历所有有计数器的 $j+1$-项集，计数器值不小于 $s$ 的即为频繁 $j+1$-项集。</li>
			</ul>
		</li>
		</ul>
		</p>
		<p>这里同样是通过牺牲时间开销的方式减少空间开销（为了方便叙述，本文描述的PCY算法和真正的PCY算法在细节上略有不同，但思想是一致的）。</p>
		<p>PCY算法有两个变种，进一步减少了空间开销。第一个变种是多阶段PCY算法（Multistage PCY Algorithm），这个算法的想法就是在一次哈希减少频繁项集候选后，再做一次哈希，再进一步减少频繁项集候选。第二个变种是多哈希PCY算法（Multihash PCY Algorithm），这个算法的想法就是一次使用多套（计数器集，哈希函数）对来增强算法筛选非频繁项集的能力。</p>
		<p>上面讲的Apriori算法变种主要是从优化空间开销的角度进行改进的，下面讲两个从优化时间开销的角度进行改进的Apriori算法变种。</p>
	</div>
</body>

</html>