<!DOCTYPE html>

<html>

<head>
	<meta charset='UTF-8'>
	<link rel='stylesheet' type='text/css' href='../css/post_style.css'>
	<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {inlineMath: [ ['$','$'], ["\\(","\\)"] ],
				  displayMath: [ ['$$','$$'], ["\\[","\\]"] ]}});
	</script>
	<script type="text/javascript" async 
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
	<title>frequent itemsets mining</title>
</head>

<body>
	<div class='navbar'>
		<ul>
			<li><a href='../index.html'>主页</a></li>
			<li></li>
		</ul>
	</div>
	<div class='post_title'>
		<b><span style='font-size:30px'>频繁项集挖掘（Frequent Itemsets Mining）</span></b>
	</div>
	<div class='post_content'>
		<p>一家超市的决策者，经常需要考虑如下两个问题。第一个问题是，如何摆放商品，或者说，该将哪些商品摆放在一起。直观上想，如果决策者能看到过去一段时间超市的营业数据，并且营业数据反映用户经常同时购买某些商品，比如经常同时购买牛奶和面包，那么决策者就应该将牛奶和面包放在一起，这样能帮助同时购买牛奶和面包的用户节省一些找商品的时间，他们的购买体验会更好。第二个问题是，假如某个商品降价了，那么其它商品的价格怎么调整，能让超市的收入更高。仍然以牛奶和面包为例，假设降价的商品是牛奶，直观上想，这时候给面包涨价应该是一个比较合适的决策。这是因为买了牛奶的用户一般也会买面包，当用户在超市里买了牛奶后，为了方便，也会在同一家超市买面包，因此将面包涨价就能增长超市的收入。</p>
		<p>在上面的例子里，我们可以看到，在超市的经营决策中，从营业数据中发现“哪些商品更可能同时被用户购买”和“用户购买了某些商品，就很可能会购买另一些商品”这类的规律是一件很有用的事情。在数据挖掘（Data Mining）领域中，频繁项集挖掘（Frequent Itemsets Mining）就是研究如何从数据中发现这类规律的一个课题，下面我将介绍这个课题最基本的定义和算法。</p>
		</br>
		<p>首先我们需要先定义这个课题所考虑的数据类型。频繁模式挖掘这个课题一般假设我们有 $n$ 个商品（Item）和 $m$ 个篮子（basket），每个篮子里有若干个商品。这 $m$ 个篮子组成的数据就称为满足购物篮模型（the Market-Basket Model）要求的数据。下面总结一下购物篮模型的定义。</p>
		<p>定义（购物篮模型）：设集合 $I$ 为商品集，$B_1,B_2,...,B_m$ 是 $I$ 的子集，那么称数据 $D=\{B_1,B_2,...,B_m\}$ 是满足购物篮模型要求的数据，并将 $B_i$ 称为第 $i$ 个篮子。</p>
		<p>为了能准确描述“哪些商品更可能同时被用户购买”这个事情，我们需要定义项集（Itemset）和频繁项集（Frequent Itemset）这两个概念。我们将商品的集合称为项集，换句话说，商品集的任一个子集，都是一个项集。一个项集 $S$ 在数据中出现的次数（包含 $S$ 的篮子的数目）称为这个项集的支持数（support），简记为 $supp(S)$。直观上想，频繁项集就是出现得比较频繁的项集，也就是支持数较大的项集。为了精确描述“频繁”这个事情，我们需要预先给定一个支持数阈值（Support Threshold），并称支持数不少于这个支持数阈值的项集为频繁项集。下面总结一下频繁项集的定义。</p>
		<p>定义（频繁项集）：设支持数阈值为 $s$，称项集 $S$ 为频繁项集，若 $supp(S)\ge s$。</p>
		<p>上面我们已经成功抽象出用于描述“哪些商品更可能同时被用户购买”的精确概念，接下来需要抽象出能够描述“用户购买了某些商品，就很可能会购买另一些商品”的精确概念。考虑两个不交的项集 $S_1$ 和 $S_2$，我们希望知道假如一个用户购买了 $S_1$ 中的全部商品后，会有多大可能购买 $S_2$。这个可能性用概率来描述就是
		$$P\{用户购买了 S_2 中的商品|用户购买了 S_1 中的商品\}=\frac{P\{用户购买了 S_1\cup S_2 中的商品\}}{P\{用户购买了 S_1 中的商品\}}$$
		为了方便，将这个公式简记为
		$$P(S_2|S_1)=\frac{P(S_1\cup S_2)}{P(S_1)}$$
		由于我们手上有用户的数据，因此可以用频率值估计这个概率值，就有
		$$\hat{P}(S_2|S_1)=\frac{\hat{P}(S_1\cup S_2)}{\hat{P}(S_1)}=\frac{\frac{supp(S_1\cup S_2)}{m}}{\frac{supp(S_1)}{m}}=\frac{supp(S_1\cup S_2)}{supp(S_1)}$$
		我们称形如“用户购买了 $S_1$ 中的全部商品，就会购买 $S_2$ 中的全部商品”这样的规则为关联规则（Association Rule），记为 $S_1\to S_2$，并称 $\hat{P}(S_2|S_1)$ 为这个关联规则的置信度（Confidence），记为 $conf(S_1\to S_2)$。下面总结一下关联规则和关联规则的置信度的定义。
		</p>
		<p>定义（关联规则）：设 $S_1$ 和 $S_2$ 是不交的项集，称“用户购买了 $S_1$ 中的全部商品，就会购买 $S_2$ 中的全部商品”为一条关联规则，记为 $S_1\to S_2$。</p>
		<p>定义（关联规则的置信度）：称关联规则 $S_1\to S_2$ 的置信度为 $conf(S_1\to S_2)=\frac{supp(S_1\cup S_2)}{supp(S_1)}$。</p>
		<p>直观上想，置信度越大的关联规则，应该是越有用的关联规则，但事实并不是这样。假设来超市购物的所有用户都买了矿泉水这个商品，那么对任意一个商品，比如铅笔，会有
		$$conf(\{铅笔\}\to\{矿泉水\})=\frac{supp(\{铅笔，矿泉水\})}{supp(\{铅笔\})}=1$$
		这条关联规则的置信度很大，但并不能反映任何因果关系，因为这时候从概率的角度来看（假设样本空间是数据），铅笔和矿泉水的购买是两个独立的事件，也就是
		$$P(\{矿泉水\}|\{铅笔\})=P(\{矿泉水\})$$
		由此可见，对于关联规则 $S_1\to S_2$，当 $\frac{\hat{P}(S_2|S_1)}{\hat{P}(S_1)}=1$ 时，这条关联规则就基本没什么用处了。因此我们将 $\frac{\hat{P}(S_2|S_1)}{\hat{P}(S_1)}$ 称为关联规则 $S_1\to S_2$ 的提升度（Lift），作为关联规则的有效性的一个评价指标。下面总结一下关联规则的提升度的定义。</p>
		<p>定义（关联规则的提升度）：称关联规则 $S_1\to S_2$ 的提升度为
		$$lift(S_1\to S_2)=\frac{\hat{P}(S_2|S_1)}{\hat{P}(S_1)}=\frac{m\cdot supp(S_1\cup S_2)}{supp(S_1)supp(S_2)}$$</p>
		<p>由提升度的定义可见，当一条关联规则的提升度较大时（远大于 $1$），就说明相比于不完全购买 $S_1$ 中的商品的用户，完全购买 $S_1$ 中的商品的用户更可能完全购买 $S_2$ 中的商品。当一条关联规则的提升度较小时（远小于 $1$），就说明相比于不完全购买 $S_1$ 中的商品的用户，完全购买 $S_1$ 中的商品的用户更不可能完全购买 $S_2$ 中的商品。当一条关联规则的提升度接近 $1$ 时，就说明用户是否完全购买 $S_2$ 中的商品，和用户是否完全购买 $S_1$ 中的商品，没有太大关系。</p>
		<p>我们一般倾向于从数据中挖掘满足 $supp(S_1\cup S_2)$ 和 $conf(S_1\to S_2)$ 都比较大的关联规则（如果 $S_1\cup S_2$ 不是频繁项集，那么这条关联规则可能不会带来太多商业利润），再用提升度等指标筛选出真正有效的关联规则。而关联规则的挖掘，可以归结为频繁项集的挖掘，只要找到所有的频繁项集，那对于任意一个频繁项集 $S$，枚举其子集 $S_1$，令 $S_2=S-S_1$，再验证置信度，就可以得到所有满足要求的关联规则。因此下面主要讨论挖掘频繁项集的算法。</p>
		</br>
		<p>本节主要叙述挖掘频繁项集的算法。先来复述一下算法需要解决的任务，如下所示。</p>
		<p>任务（频繁项集挖掘）：给定数据，预先定义整数 $k$ 和 $s$，求满足有 $k$ 个商品，并且支持数不少于 $s$ 的全体项集。</p>
		<p>首先，很容易给出一个暴力算法（Brute-Force Algorithm）作为解法，如下所示。</p>
		<p>算法（暴力算法）：
		<ul>
		<li>给 $C_n^k$ 个频繁项集候选各自分配一个计数器。</li>
		<li>遍历数据，对每个篮子，枚举它的全体包含 $k$ 个商品的子集，对这些项集的计数器加 $1$。</li>
		<li>遍历 $C_n^k$ 个频繁项集候选，返回计数器值不小于 $s$ 的项集。</li>
		</ul>
		</p>
		<p>可以看到，这个暴力算法不管是在时间复杂度，还是空间复杂度上，都是很爆炸的。时间复杂度倒是能勉强接受，这是因为实际使用中，篮子的元素数目和 $k$ 的值一般很小，因此对计数器的操作次数也不会特别多。但空间复杂度经常是没法接受的，因为商品数量 $n$ 一般是很大的，内存的存储空间可能不够维护 $C_n^k$ 个计数器。</p>
	</div>
</body>

</html>